package main

import (
	"bytes"
	"flag"
	"fmt"
	"github.com/ganluo960214/StringCase"
	"github.com/go-playground/validator/v10"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
)

/*
env
*/
var (
	GOFILE    = os.Getenv("GOFILE")
	GOPACKAGE = os.Getenv("GOPACKAGE")
)

/*
validator
*/
var (
	validate = validator.New()
)

/*
flags
*/
var (
	flags = struct {
		Type        string `validate:"required"`
		Table       string
		FileName    string
		IsAddImport bool
	}{}
)

func init() {
	flag.StringVar(&flags.Type, "type", "", "type name; must be set")
	flag.StringVar(&flags.Table, "table", "", "table name in database; default as \"-type\"")
	flag.StringVar(&flags.FileName, "file-name", "", "newly generated file name; default as \"-type_stitching_sql.go\"") // flag -file-name-type
	flag.BoolVar(&flags.IsAddImport, "is-add-import", true, "only for develop, ignore it.")
}

/*
init log and flag
*/
func init() {
	log.SetFlags(0)
	flag.Parse()
}

/*
file template
*/
type FileTemplateContent struct {
	Type        string
	Package     string
	Table       string
	FieldMapper map[string]string // map[struct field]table field
	IsAddImport bool
}

const FileTemplate = `// Code generated by "gml -type={{.Type}}"; DO NOT EDIT.

package {{.Package}}

{{if .IsAddImport}}import Stitching_SQL_Go "github.com/ganLuo960214/StitchingSQLGO"{{end}}

// --- table ---
func (t {{.Type}}) SQLTable() string {
	return "{{.Table}}"
}

// --- field ---
type generate{{.Type}}field struct {
	{{range $k,$v:= .FieldMapper}}
		{{$k}} {{if $.IsAddImport}}Stitching_SQL_Go.{{end}}SQLField{{end}}
}

var (
	{{.Type}}_F = generate{{.Type}}field { {{range $k,$v:= .FieldMapper}}
		{{$k}}: generate{{$.Type}}field{{$k}}{},{{end}}
	}
)

{{range $k,$v:= .FieldMapper}}
// --- generate {{$.Table}} table {{$v}} Field
type generate{{$.Type}}field{{$k}} struct{}

func (f generate{{$.Type}}field{{$k}}) SQLTable() string {
	return {{$.Type}}{}.SQLTable()
}
func (f generate{{$.Type}}field{{$k}}) SQLField() string {
	return "{{$v}}" 
}
{{end}}

`

func main() {
	// flags validator
	if err := validate.Struct(&flags); err != nil {
		log.Fatal(err)
	}

	if _, err := os.Stat(GOFILE); os.IsNotExist(err) {
		log.Fatal(err)
	}

	// ast analysis
	fset := token.NewFileSet()
	astF, err := parser.ParseFile(fset, GOFILE, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	// file template content
	ftc := FileTemplateContent{
		Type:        flags.Type,
		Package:     GOPACKAGE,
		Table:       flags.Table,
		FieldMapper: map[string]string{},
		IsAddImport: flags.IsAddImport,
	}

	if flags.Table == "" {
		ftc.Table = StringCase.ToSnakeCase(flags.Type)
	}

	isFindType := false
	ast.Inspect(astF, func(n ast.Node) bool {
		t, ok := n.(*ast.TypeSpec)
		if ok == false {
			return true
		}

		s, ok := t.Type.(*ast.StructType)
		if ok == false {
			return true
		}

		if t.Name.Name != flags.Type {
			return false
		}
		isFindType = true
		for _, f := range s.Fields.List {
			n := f.Names[0].Name
			ftc.FieldMapper[n] = StringCase.ToSnakeCase(n)
		}

		return false
	})

	if !isFindType {
		log.Fatal("-type error, not find type as struct")
	}

	// file content container
	b := bytes.NewBuffer([]byte{})

	// new file template
	t, err := template.New("").Funcs(template.FuncMap{
		"stringsJoin": strings.Join,
	}).Parse(FileTemplate)
	if err != nil {
		log.Fatal(err)
	}
	// generate file content write to file content container
	if err := t.Execute(b, ftc); err != nil {
		log.Fatal(err)
	}

	// file name
	fileName := fmt.Sprintf("%s_stitching_sql.go", flags.Type)
	if flags.FileName != "" {
		fileName = flags.FileName
	}

	content, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := ioutil.WriteFile(fileName, content, 0644); err != nil {
		log.Fatal(err)
	}
}
